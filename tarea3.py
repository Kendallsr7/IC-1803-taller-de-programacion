# -*- coding: utf-8 -*-
"""Tarea3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ELhT2tMRf0SoiZyMnzxWddHquqkTrb_d

1. MCD: Este problema consiste en recibir dos números enteros e indicar cuál es el máximo común divisor
de ambos números. Para este ejercicio, idee una forma de hacerlo sin el algoritmo de Euclides.
"""

def mcd(a, b):
    if a == b:
        return a
    elif a > b:
        return mcd(a - b, b)
    return mcd(a, b - a)

print(mcd(54, 33))

"""2. MCD*: Programe este mismo ejercicio pero utilizando el algoritmo de Euclides."""

def mcd_eu(a, b):
    if b == 0:
        return a
    else:
        return mcd_eu(b, a % b)

print(mcd(54, 33))

"""3. mcm: Este problema consiste en recibir dos números enteros e indicar cuál es el mínimo común múltiplo
de ambos números. ¿De alguna manera se puede utilizar el ejercicio anterior de MCD? ¿Cuál de los
dos utilizaría?
"""

def mcm(a, b):
    return (a * b) // mcd_eu(a, b)

print(mcm(54, 33))

"""4. Suma de cubos: Para este ejercicio programe la siguiente fórmula (el n es recibido como parámetro)"""

def suma_cubos(a, b):
  if a > b:
    return 0
  return a * a * a + suma_cubos(a + 1, b)

print(suma_cubos(1, 10))

"""5. Es primo?: Este problema consiste en recibir un número natural e indicar por medio de un true o un
false si el número es primo o no (Verdadero si es primo y falso si no lo es). Un número primo es aquel
que sólo posee dos divisores enteros, 1 y sí mismo. Busque realizar el ejercicio en el mínimo número de
pasos posible.
"""

def es_primo_aux(n, i):
    if n <= 2:
        return n == 2
    if n % i == 0:
        return False
    if i * i > n:
        return True
    return es_primo_aux(n, i + 1)

def es_primo(n):
  return es_primo_aux(n, 2)

print(es_primo(70))
print(es_primo(71))

"""6. n-simo primo: Este problema, similar al anterior, recibe un n y retorna el n-símo número primo, por
ejemplo, si recibe un 1 devuelve un 2, porque 2 es el primer número primo. Si recibe un 4, entonces
devuelve 7, porque es el cuarto número primo.
"""

def n_simo_primo_aux(n, a, i, t):
  if n == t:
    return a
  elif es_primo(i):
    return n_simo_primo_aux(n, i, i + 1, t + 1)
  return n_simo_primo_aux(n, a, i + 1, t)

def n_simo_primo(n):
  return n_simo_primo_aux(n, 2, 3, 1)

print(n_simo_primo(8))

"""7. Cantidad de dígitos: Este programa busca crear un algoritmo que reciba un número entero con una
cantidad de dígitos arbitraria y retorne la cantidad de dígitos que tiene ese número. Por ejemplo, si
recibe 23544, devuelve 5.
"""

def cantidad_digitos(n):
  if (n < 10):
    return 1
  return 1 + cantidad_digitos(n / 10)

print(cantidad_digitos(23544))

"""8. Invertir un número: Este problema consiste en invertir el orden en que aparecen los dígitos de un número
natural. Por ejemplo, si entra un 1853, entonces se retorna un 3581. Dentro de los casos curiosos, es
que si entra el 1000, entonces tiene que retornar 1. (Nótese que 0001 tiene tres ceros a la izquierda y
por lo tanto no cuentan)
"""

def invertir_numero(numero, invertido=0):
    if numero == 0:
        return invertido
    invertido = (invertido * 10) + (numero % 10)
    return invertir_numero(numero // 10, invertido)

print(invertir_numero(1853))

"""9. Factorial: Este programa debe recibir un número n y calcular n! el cual es el producto desde 1 hasta
n. Por ejemplo: 5! = 1 × 2 × 3 × 4 × 5 = 120.
"""

def factorial(n):
  if n < 2:
    return 1
  return n * factorial(n - 1)

print(factorial(5))

"""10. Suma de fracciones"""

def pow(b, e):
  if e == 0:
    return 1
  elif e == 1:
    return b
  m = e // 2
  res = pow(b, m)
  res = res * res
  if e % 2 == 1:
    res = res * b
  return res

def suma_frac(a, b):
  if a > b:
    return 0
  return (pow(-1, a) // a) + suma_frac(a + 1, b)

print(suma_frac(1, 10))

"""11. Suma de suma"""

def sumita(a, b):
  if a > b:
    return 0
  return (a * b) + sumita(a + 1, b)

def suma_de_suma(a, b):
  if a > b:
    return 0
  return sumita(1, a) + suma_de_suma(a + 1, b)

print(suma_de_suma(1, 10))

"""12. Producto"""

def multi(i, n):
  if i > n:
    return 1
  return (1 / pow(2, i)) * multi(i + 1, n)

print(multi(1, 10))

"""13. Producto de sumas"""

def summ(a, i, b):
  if a > b: return 0
  return (2 * i / a) + summ(a + 1, i, b)

def multi_sum(i, n):
  if i > n:
    return 1
  return summ(1, i, i * i) * multi_sum(i + 1, n)

print(multi_sum(1, 10))

"""14. Mezcla general"""

def m1(res, i, j, k, n):
  if k > n: return res
  res = res * ((2 * i) + (3 * j) + (k))
  return m1(res, i, j, k + 1, n)

def s1(res, i, j, n):
  if j > n: return res
  res = res + m1(1, i, j, j, n * n)
  return s1(res, i, j + 1, n)

def m2(res, i, n):
  if i > n: return res
  res = res * s1(0, i, i, n)
  return m2(res, i + 1, n)

def mezcla(n):
  return m2(1, 1, n)

print(mezcla(2))

"""15. Números perfectos, abundantes o deficientes"""

def suma_factores_propios(numero, divisor, suma):
    if divisor == numero: return suma
    if numero % divisor == 0: suma += divisor
    return suma_factores_propios(numero, divisor + 1, suma)

def tipo_numero(numero):
    suma = suma_factores_propios(numero, 1, 0)
    if suma == numero: return 0
    elif suma < numero: return -1
    else: return 1

print(tipo_numero(12))
print(tipo_numero(5))
print(tipo_numero(6))

"""16. Números amigos"""

import sys
sys.setrecursionlimit(100000)

def suma_factores_propios(numero, divisor, suma):
    if divisor == numero: return suma
    if numero % divisor == 0: suma = suma + divisor
    return suma_factores_propios(numero, divisor + 1, suma)

def son_amigos(a, b):
    suma_a = suma_factores_propios(a, 1, 0)
    suma_b = suma_factores_propios(b, 1, 0)
    return suma_a == b and suma_b == a

def buscar_amigo(numero, candidato):
    if candidato == numero: return -1

    suma_candidato = suma_factores_propios(candidato, 1, 0)

    if son_amigos(numero, suma_candidato): return candidato

    return buscar_amigo(numero, candidato + 1)

print(buscar_amigo(2, 1))
print(son_amigos(220, 284))

"""17. Según indica la conjetura de Goldbach para un número par, existen dos números primos tales que
sumados den ese número
"""

def encontrar_primos_par(par, primer_primo):
    if es_primo(par - primer_primo):
        return [primer_primo, par - primer_primo]
    return encontrar_primos_par(par, primer_primo + 1)

def encontrar_primos(par):
    return encontrar_primos_par(par, 2)

print(encontrar_primos(4))
print(encontrar_primos(10))

"""18. Según el teorema de los cuatro cuadrados, existen para todo n, cuatro números enteros que elevados
al cuadrado suman n.
"""

def combinar_c(a, b, n, cuadrados):
    if a > b:
        return
    encontrar_cuadrados(n - pow(a, 2), cuadrados + [a])
    combinar_c(a + 1, b, n, cuadrados)

def encontrar_cuadrados(n, cuadrados=[]):
    if n == 0 and len(cuadrados) == 4:
        print(cuadrados)
    elif n > 0 and len(cuadrados) < 4:
        combinar_c(1, int(pow(n, 0.5)), n, cuadrados)

encontrar_cuadrados(25)

"""19. Análogo al ejercicio anterior, también existe un teorema que indica que un número puede expresarse
como la suma de tres números triangulares.
"""

def numero_triangular(n):
  return (n * (n + 1)) // 2

def combinar_t(i, n, triangulos):
  if i == n: return
  encontrar_triangulos(n, triangulos + [numero_triangular(i)], i)
  combinar_t(i + 1, n, triangulos)

def encontrar_triangulos(n, triangulos=[], i=1):
  if len(triangulos) == 3 and sum(triangulos) == n:
      print(triangulos)
  elif sum(triangulos) < n:
    combinar_t(i, n, triangulos)

encontrar_triangulos(12)

"""20. Como se pudo apreciar en los dos ejercicios anteriores, existen varios tríos o cuartetos que vienen con
un cero, lo que quiere decir que hay números que pueden expresarse como menos de 3 triangulares
o de 4 cuadrados.
"""

def combinar_cm(a, b, n, cuadrados):
    if a > b:
        return
    encontrar_cuadradosm(n - pow(a, 2), cuadrados + [a])
    combinar_cm(a + 1, b, n, cuadrados)

minc = []

def encontrar_cuadradosm(n, cuadrados=[]):
    global minc
    if n == 0 and len(cuadrados) <= 4:
        if(len(minc) == 0 or len(minc) > len(cuadrados)):
          minc = cuadrados
    elif n > 0 and len(cuadrados) < 4:
        combinar_cm(1, int(pow(n, 0.5)), n, cuadrados)

encontrar_cuadradosm(25)
print(minc)

def numero_triangular_m(n):
  return (n * (n + 1)) // 2

def combinar_tm(i, n, triangulos):
  if i == n: return
  encontrar_triangulosm(n, triangulos + [numero_triangular_m(i)], i)
  combinar_tm(i + 1, n, triangulos)

mint = []

def encontrar_triangulosm(n, triangulos=[], i=1):
  global mint
  if len(triangulos) <= 3 and sum(triangulos) == n:
      if(len(mint) == 0 or len(mint) > len(triangulos)):
          mint = triangulos
  elif sum(triangulos) < n:
    combinar_tm(i, n, triangulos)

encontrar_triangulosm(12)
print(mint)

"""21. Según el teorema de Carmichael, para el n-simo (n > 12) número de fibonacci, existe un primo que es
factor de ese número y que no es factor de ningún otro número de fibonacci previo.
"""
def siguiente_primo(primo):
    siguiente = primo + 1
    if es_primo(siguiente):
        return siguiente
    else:
        return siguiente_primo(siguiente)

def siguiente_primo(primo):
    siguiente = primo + 1
    while not es_primo(siguiente):
        siguiente += 1
    return siguiente

def n_esimo_fibonacci(n):
    if n < 2:
        return n
    return n_esimo_fibonacci(n - 1) + n_esimo_fibonacci(n - 2)

def primo_que_divide_fibonacci(n, primo=2):
    fibonacci = n_esimo_fibonacci(n)
    if fibonacci in (1, 2, 6, 12):
        return -1
    if fibonacci % primo == 0:
        return primo
    siguiente = siguiente_primo(primo)
    return primo_que_divide_fibonacci(n, siguiente)

print(n_esimo_fibonacci(14))
print(primo_que_divide_fibonacci(14))

"""Conversor de bases 2 - 10"""

def decimal_a_base(decimal, base):
    if decimal == 0:
        return 0

    return (decimal % base + 10 * decimal_a_base(decimal // base, base))

def a_decimal(numero, b, decimal, i):
    if numero == 0:
        return decimal

    digito = numero % 10
    decimal = decimal + digito * (b ** i)
    numero = numero // 10
    return a_decimal(numero, b, decimal, i + 1)

def convertir_base(numero, base_origen, base_destino):
    numero_decimal = a_decimal(numero, base_origen, 0, 0)
    numero_convertido = decimal_a_base(numero_decimal, base_destino)
    return numero_convertido

print(convertir_base(6, 10, 2))
print(convertir_base(110, 2, 10))

"""Conversor de bases 2 - 36"""

def a_decimal_l(numero, base, potencia=0):
    if numero == "":
        return 0
    digito = numero[-1]
    if digito.isdigit():
        valor_digito = int(digito)
    else:
        valor_digito = ord(digito) - ord('A') + 10
    return valor_digito * (base ** potencia) + a_decimal_l(numero[:-1], base, potencia + 1)

def decimal_a_base_l(decimal, base):
    if decimal == 0:
        return ""

    resto = decimal % base
    if resto < 10:
        resto_str = str(resto)
    else:
        resto_str = chr(resto + ord('A') - 10)
    return decimal_a_base_l(decimal // base, base) + resto_str

def convertir_base_l(numero, base_origen, base_destino):
    decimal = a_decimal_l(numero, base_origen)
    return decimal_a_base_l(decimal, base_destino)

print(convertir_base_l("1Z", 36, 10))
print(convertir_base_l("110", 2, 13))